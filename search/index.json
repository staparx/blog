[{"content":"图数据库GDB的使用 - Gremlin 公司需求开发中，产品提出想要绘画出人员关系图。关系型数据库不太适合该场景，因此引入了图数据库（阿里云GDB）。\nGremlin Gremlin中文文档\n复杂场景实战 通用场景类 求两个用户A和B的共同好友数 下面输出A的好友数、B的好友数、共同好友数\n1 2 3 4 5 6 7 g.inject(\u0026#39;any\u0026#39;). sideEffect(g.V(\u0026#39;A\u0026#39;).bothE().otherV().aggregate(\u0026#39;v1\u0026#39;)). sideEffect(g.V(\u0026#39;B\u0026#39;).bothE().otherV().aggregate(\u0026#39;v2\u0026#39;)). project(\u0026#39;count1\u0026#39;, \u0026#39;count2\u0026#39;, \u0026#39;countMerge\u0026#39;). by(select(\u0026#39;v1\u0026#39;).unfold().count()). by(select(\u0026#39;v2\u0026#39;).unfold().count()). by(select(\u0026#39;v1\u0026#39;).unfold().where(within(\u0026#39;v2\u0026#39;)).count()) K个用户的共同好友 上面的情况进一步拓展，要求K个好友的共同好友，假定求1，3，5这三个用户的共同好友，可以这样计算。\n1 2 gremlin\u0026gt; g.V(1, 3, 5).both().groupCount().unfold().where(select(values).is(3)).select(keys) ==\u0026gt;v[4] 如果5是超级顶点，则可以这样计算。 方法3： 如果5是超级点，1，3是一般的点\n1 2 g.V(1,3).both().as(\u0026#34;x\u0026#34;).both().where(id().is(5)). select(\u0026#34;x\u0026#34;).groupCount().unfold().where(select(values).is(2)).select(keys) 排名前三的网络大V 社交场景中，大V往往是根据粉丝的数量来衡量，粉丝越多说明越受欢迎，加入我们要找到拥有粉丝最多的三个大V，可以这样找\n1 g.V().project(\u0026#39;user\u0026#39;,\u0026#39;degree\u0026#39;).by().by(inE().count()).order().by(select(\u0026#39;degree\u0026#39;), desc).limit(3) 图数据分布 以巴拉巴西为代表的科学家们发现了大量满足幂律的网络结构，这种网络被称为无标度网络。人们越来越倾向于认为，幂律（Power Law）是无处不在规律，尤其在复杂网络中。\n找和A同公司的上三届师兄、师姐 小A刚入职，可以将本公司小A的师兄、师姐推荐给小A，让小A尽量通过熟人的帮助尽快融入工作小圈子，可以这样写。\n1 2 3 4 5 6 g.V().hasLabel(\u0026#39;person\u0026#39;).hasId(\u0026#39;A\u0026#39;). sideEffect(out(\u0026#39;workAt\u0026#39;).aggregate(\u0026#39;company\u0026#39;)). outE(\u0026#39;studyAt\u0026#39;).has(\u0026#39;classYear\u0026#39;, \u0026#39;2009\u0026#39;).inV(). // 求学于哪个学校 inE(\u0026#39;studyAt\u0026#39;).has(\u0026#39;classYear\u0026#39;, within(\u0026#39;2009\u0026#39;, \u0026#39;2008\u0026#39;, \u0026#39;2007\u0026#39;, \u0026#39;2006\u0026#39;)). outV().has(id, neq(\u0026#39;p1024\u0026#39;)). //该学校06-09年毕业的其他学生 where(out(\u0026#39;workAt\u0026#39;).where(within(\u0026#39;company\u0026#39;))) // 也再该公司的校友集合 多级遍历 \u0026amp; 每级只关注特定点 这种场景是k跳遍历的一种特殊情况，再每一跳中，我们只关注top1，这里的top1可以为某个属性的权重等，这种场景再金融领域也比较场景, 比如我们再每一跳中，只取weight权重最高的这条边，并沿着这条边一直走到终点。\n1 2 3 gremlin\u0026gt; g.V(1).repeat(__.flatMap(outE(\u0026#34;knows\u0026#34;).order().by(\u0026#39;weight\u0026#39;,desc).limit(1).otherV())). until(__.not(outE(\u0026#34;knows\u0026#34;))).path() ==\u0026gt;[v[1],v[4]] 多层级链路探索发现(股权穿透)类请求 从某个点出发，不断的向外拓展，找出一个联通子图\n1 2 3 4 5 6 7 gremlin\u0026gt; g.V(1).repeat(both().dedup()).emit() ==\u0026gt;v[3] ==\u0026gt;v[2] ==\u0026gt;v[4] ==\u0026gt;v[1] ==\u0026gt;v[6] ==\u0026gt;v[5] 根据特定点边数量进行路径过滤 比如有个sql从start开始， PeopleA和PeopleB两个分支，用户需要根据每个分支的边的数量进行过滤，比如上图中PeopleA有两个路径，PeopleB只有一个路径，此时选择路径A，这个sql如何写？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ==\u0026gt;All scripts will now be evaluated locally - type \u0026#39;:remote console\u0026#39; to return to remote mode for Gremlin Server - [localhost/127.0.0.1:3002] gremlin\u0026gt; g.V().as(\u0026#34;1\u0026#34;).out().as(\u0026#34;2\u0026#34;).project(\u0026#34;f\u0026#34;, \u0026#34;e\u0026#34;).by(select(\u0026#34;1\u0026#34;)).by(select(\u0026#34;2\u0026#34;)) ==\u0026gt;[f:v[1],e:v[3]] ==\u0026gt;[f:v[1],e:v[2]] ==\u0026gt;[f:v[1],e:v[4]] ==\u0026gt;[f:v[4],e:v[5]] ==\u0026gt;[f:v[4],e:v[3]] ==\u0026gt;[f:v[6],e:v[3]] gremlin\u0026gt; g.V().as(\u0026#34;1\u0026#34;).out().as(\u0026#34;2\u0026#34;).project(\u0026#34;f\u0026#34;, \u0026#34;e\u0026#34;).by(select(\u0026#34;1\u0026#34;)).by(select(\u0026#34;2\u0026#34;)). group().by(select(\u0026#34;f\u0026#34;)) ==\u0026gt;[v[1]:[[f:v[1],e:v[3]],[f:v[1],e:v[2]],[f:v[1],e:v[4]]], v[4]:[[f:v[4],e:v[5]],[f:v[4],e:v[3]]], v[6]:[[f:v[6],e:v[3]]]] gremlin\u0026gt; g.V().as(\u0026#34;1\u0026#34;).out().as(\u0026#34;2\u0026#34;).project(\u0026#34;f\u0026#34;, \u0026#34;e\u0026#34;).by(select(\u0026#34;1\u0026#34;)).by(select(\u0026#34;2\u0026#34;)). group().by(select(\u0026#34;f\u0026#34;)).select(values) ==\u0026gt;[[[f:v[1],e:v[3]],[f:v[1],e:v[2]],[f:v[1],e:v[4]]], [[f:v[4],e:v[5]],[f:v[4],e:v[3]]], [[f:v[6],e:v[3]]]] gremlin\u0026gt; g.V().as(\u0026#34;1\u0026#34;).out().as(\u0026#34;2\u0026#34;).project(\u0026#34;f\u0026#34;, \u0026#34;e\u0026#34;).by(select(\u0026#34;1\u0026#34;)).by(select(\u0026#34;2\u0026#34;)). group().by(select(\u0026#34;f\u0026#34;)).select(values). //按照f第一列进行聚合，并选择values unfold().where(count(local).is(gte(2))). //聚合后，去掉外层的list，并求内层的数量，过滤 unfold() // 最后再unfold，即为结果 ==\u0026gt;[f:v[1],e:v[3]] ==\u0026gt;[f:v[1],e:v[2]] ==\u0026gt;[f:v[1],e:v[4]] ==\u0026gt;[f:v[4],e:v[5]] ==\u0026gt;[f:v[4],e:v[3]] 路径探索类 两点之间最短路径 根据6度理论，再社交场景中，任何两个点的距离都在6度以内。如果小A有急事需要找著名医院的小B医生帮忙，可以A和B之间有无数路径，我们只关注最短的路径，从而提高求助效率。可以这样写。\n1 2 3 g.V(\u0026#34;A\u0026#34;).repeat(both().simplePath()). until(hasId(\u0026#34;B\u0026#34;).or().loops().is(gt(6L))). hasId(\u0026#34;B\u0026#34;).path().limit(1) 带权重的最短路径 有时候最短路径并不是按照hop跳数定义，而是根据边上的某些属性定义，这样稍微复杂点，比如下图，1 - 3之间有两条路径，按照边的weight属性累积求和作为路径的权重，从而求出最短路径。\n1 2 3 4 5 6 gremlin\u0026gt; g.V(\u0026#34;1\u0026#34;).repeat(outE().inV().simplePath()). until(hasId(\u0026#34;3\u0026#34;).or().loops().is(gt(1))).hasId(\u0026#34;3\u0026#34;).path().as(\u0026#34;p\u0026#34;). map(unfold().coalesce(values(\u0026#34;weight\u0026#34;), constant(0.0)).sum()).as(\u0026#34;cost\u0026#34;). select(\u0026#34;cost\u0026#34;,\u0026#34;p\u0026#34;).order().by(select(\u0026#34;cost\u0026#34;), Order.incr) ==\u0026gt;[cost:0.4,p:[v[1],e[9][1-created-\u0026gt;3],v[3]]] ==\u0026gt;[cost:1.4,p:[v[1],e[8][1-knows-\u0026gt;4],v[4],e[11][4-created-\u0026gt;3],v[3]]] 股权穿透/多级分销 这类场景再企业控股类场景，比如a持股b 50%； b持股c 50%，则a持股c 25%；或者社交产品分销场景中非常常见。\n1 2 3 4 5 6 7 8 9 gremlin\u0026gt; g.withSack(1.0f).V(\u0026#34;1\u0026#34;). repeat(outE().sack(mult).by(\u0026#34;weight\u0026#34;).inV().simplePath()) .emit().path().as(\u0026#34;p\u0026#34;).sack().as(\u0026#34;cost\u0026#34;). select(\u0026#34;cost\u0026#34;,\u0026#34;p\u0026#34;).order().by(select(\u0026#34;cost\u0026#34;),Order.desc) ==\u0026gt;[cost:1.0,p:[v[1],e[8][1-knows-\u0026gt;4],v[4]]] ==\u0026gt;[cost:1.0,p:[v[1],e[8][1-knows-\u0026gt;4],v[4],e[10][4-created-\u0026gt;5],v[5]]] ==\u0026gt;[cost:0.5,p:[v[1],e[7][1-knows-\u0026gt;2],v[2]]] ==\u0026gt;[cost:0.4,p:[v[1],e[9][1-created-\u0026gt;3],v[3]]] ==\u0026gt;[cost:0.4,p:[v[1],e[8][1-knows-\u0026gt;4],v[4],e[11][4-created-\u0026gt;3],v[3]]] 股权穿透保留符合特定条件的路径 比如在股权累乘时只保留 累乘结果 \u0026gt; 0.5的路径，过滤掉 \u0026lt;= 0.5的路径，可以参考：\n1 2 3 4 5 6 7 gremlin\u0026gt; g.withSack(1.0f).V(\u0026#34;1\u0026#34;).repeat(outE().sack(mult).by(\u0026#34;weight\u0026#34;).where(sack().is(gte(0.5))).inV().simplePath()).emit().path().as(\u0026#34;p\u0026#34;).sack().as(\u0026#34;cost\u0026#34;).select(\u0026#34;cost\u0026#34;, \u0026#34;p\u0026#34;) gremlin\u0026gt; g.withSack(1.0f).V(\u0026#34;1\u0026#34;). repeat(outE().sack(mult).by(\u0026#34;weight\u0026#34;).where(sack().is(gte(0.5))).inV().simplePath()). emit().path().as(\u0026#34;p\u0026#34;).sack().as(\u0026#34;cost\u0026#34;).select(\u0026#34;cost\u0026#34;, \u0026#34;p\u0026#34;) ==\u0026gt;[cost:0.5,p:[v[1],e[7][1-knows-\u0026gt;2],v[2]]] ==\u0026gt;[cost:1.0,p:[v[1],e[8][1-knows-\u0026gt;4],v[4]]] ==\u0026gt;[cost:1.0,p:[v[1],e[8][1-knows-\u0026gt;4],v[4],e[10][4-created-\u0026gt;5],v[5]]] 路径按边进行去重 不同于neo4j的path默认是边去重。gremlin查询语言的path去重是不区分点和边，也就是按照path中的object对象进行去重。\n1 2 3 4 5 ## 如果使用下面方式，则会出现A-D-A-D循环，一般不是用户需要的 g.V(\u0026#34;A\u0026#34;).repeat(bothE().otherV()).until(hasId(3).or().loops().is(gte(4))).hasId(3) ## 如果使用simplePath方式，则不会出现A-D-E-D这条路径，虽然D-E之间有两条路径 g.V(\u0026#34;A\u0026#34;).repeat(bothE().otherV().simplePath()).until(hasId(3).or().loops().is(gte(4))).hasId(3) 如果需要上述中A-D-E-D这种路径，但又不希望A-D之间的边重复多次，这种场景就是典型的边去重模式，可惜目前gremlin的框架不支持，相关讨论参考gremlin-users讨论。即使如此，用gremlin的用户依然可以有两种方案来规避：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ## 方案1. 使用groovy语法 gremlin\u0026gt; g.withSack {[\u0026#39;~~\u0026#39;]}{it.clone()}.V(1).repeat(bothE().as(\u0026#34;e\u0026#34;).filter(__.sack().as(\u0026#34;list\u0026#34;).select(\u0026#34;e\u0026#34;).where(without(\u0026#34;list\u0026#34;))).sack{m,v -\u0026gt; m += v; m}.otherV()).times(2).path() ==\u0026gt;[v[1],e[9][1-created-\u0026gt;3],v[3],e[11][4-created-\u0026gt;3],v[4]] ==\u0026gt;[v[1],e[9][1-created-\u0026gt;3],v[3],e[12][6-created-\u0026gt;3],v[6]] ==\u0026gt;[v[1],e[8][1-knows-\u0026gt;4],v[4],e[10][4-created-\u0026gt;5],v[5]] ==\u0026gt;[v[1],e[8][1-knows-\u0026gt;4],v[4],e[11][4-created-\u0026gt;3],v[3]] ==\u0026gt;[v[1],e[8][1-knows-\u0026gt;4],v[4],e[0][5-fake-\u0026gt;4],v[5]] ## 解释 g.withSack {[\u0026#39;~~\u0026#39;]}{it.clone()}.V(1). repeat(bothE().as(\u0026#34;e\u0026#34;). filter(__.sack().as(\u0026#34;list\u0026#34;).select(\u0026#34;e\u0026#34;).where(without(\u0026#34;list\u0026#34;))). //往外跳时，对边做过滤 sack{m,v -\u0026gt; m += v; m}.otherV()). //将新的边插入到sack中，表示该边已经被过滤过 times(2).path() //循环2度并退出循环 作为对比，非边去重的结果，可以看到edge 9再path中出现两次： gremlin\u0026gt; g.withSack {[\u0026#39;~~\u0026#39;]}{it.clone()}.V(1).repeat(bothE().as(\u0026#34;e\u0026#34;).sack{m,v -\u0026gt; m += v; m}.otherV()).times(2).path() ==\u0026gt;[v[1],e[9][1-created-\u0026gt;3],v[3],e[9][1-created-\u0026gt;3],v[1]] ==\u0026gt;[v[1],e[7][1-knows-\u0026gt;2],v[2],e[7][1-knows-\u0026gt;2],v[1]] ... ## 方案2. 先不考虑边重复问题，找到结果。并对最终每个path进行判断，判断其是否有重复的边 gremlin\u0026gt; g.V(1).repeat(bothE().otherV()).until(hasId(3).or().loops().is(gte(4))).hasId(3).path().as(\u0026#34;p\u0026#34;).flatMap(unfold().group().by(choose(hasLabel(\u0026#34;person\u0026#34;, \u0026#34;software\u0026#34;), __.constant(\u0026#34;v\u0026#34;), __.constant(\u0026#34;e\u0026#34;)))).select(\u0026#34;e\u0026#34;).as(\u0026#34;origin_e\u0026#34;).dedup(local).as(\u0026#34;dedup_e\u0026#34;).filter(select(\u0026#34;dedup_e\u0026#34;, \u0026#34;origin_e\u0026#34;).by(count(local)).where(\u0026#34;dedup_e\u0026#34;, eq(\u0026#34;origin_e\u0026#34;))).select(\u0026#34;p\u0026#34;) ==\u0026gt;[v[1],e[9][1-created-\u0026gt;3],v[3]] ==\u0026gt;[v[1],e[8][1-knows-\u0026gt;4],v[4],e[11][4-created-\u0026gt;3],v[3]] ==\u0026gt;[v[1],e[8][1-knows-\u0026gt;4],v[4],e[10][4-created-\u0026gt;5],v[5],e[0][5-fake-\u0026gt;4],v[4],e[11][4-created-\u0026gt;3],v[3]] ==\u0026gt;[v[1],e[8][1-knows-\u0026gt;4],v[4],e[0][5-fake-\u0026gt;4],v[5],e[10][4-created-\u0026gt;5],v[4],e[11][4-created-\u0026gt;3],v[3]] gremlin\u0026gt; g.V(1).repeat(bothE().otherV()).until(hasId(3).or().loops().is(gte(4))).hasId(3). path().as(\u0026#34;p\u0026#34;). // 求出所有path flatMap(unfold().group(). //path按照点、边进行聚合 by(choose(hasLabel(\u0026#34;person\u0026#34;, \u0026#34;software\u0026#34;), __.constant(\u0026#34;v\u0026#34;), __.constant(\u0026#34;e\u0026#34;)))). select(\u0026#34;e\u0026#34;).as(\u0026#34;origin_e\u0026#34;).dedup(local).as(\u0026#34;dedup_e\u0026#34;). // 对边进行去重 filter(select(\u0026#34;dedup_e\u0026#34;, \u0026#34;origin_e\u0026#34;).by(count(local)). // 如果去重后count一样，说明没有重复 where(\u0026#34;dedup_e\u0026#34;, eq(\u0026#34;origin_e\u0026#34;))). select(\u0026#34;p\u0026#34;) 联通子图 A点K度范围内 到 B点构建的联通子图 和路径搜索类-两点之间最短路径场景非常类似，不过用户期望A的K度邻居范围内只要有B点，则将A、B和A的K度邻居组成一个联通子图，比如：用户需要A的4度邻居与C组成的联通子图：\n用gremlin的写入如下所示：\n1 2 3 4 5 6 7 8 9 gremlin\u0026gt; g.V(\u0026#39;1\u0026#39;).aggregate(\u0026#39;vertex\u0026#39;).repeat(bothE().aggregate(\u0026#39;edge\u0026#39;).otherV().aggregate(\u0026#39;vertex\u0026#39;)).until(loops().is(gte(1))).tail(1).V(3).as(\u0026#34;dst\u0026#34;).where(\u0026#34;dst\u0026#34;, within(\u0026#34;vertex\u0026#34;)).select(\u0026#39;vertex\u0026#39;, \u0026#39;edge\u0026#39;).by(dedup(local)).by(dedup(local)) ==\u0026gt;[vertex:[v[1],v[3],v[2],v[4]],edge:[e[9][1-created-\u0026gt;3],e[7][1-knows-\u0026gt;2],e[8][1-knows-\u0026gt;4]]] # 解释 以起点为1，终点为3， khop为1， 及1的1跳内连通图包含3构成的子图 gremlin\u0026gt; g.V(\u0026#39;1\u0026#39;).aggregate(\u0026#39;vertex\u0026#39;). repeat(bothE().aggregate(\u0026#39;edge\u0026#39;).otherV().aggregate(\u0026#39;vertex\u0026#39;)). // 将中间的点和边进行汇聚存储 until(loops().is(gte(1))).tail(1). //1跳，取最后一行 V(3).as(\u0026#34;dst\u0026#34;).where(\u0026#34;dst\u0026#34;, within(\u0026#34;vertex\u0026#34;)). // 联通子图中的点需要用终点3进行判断 select(\u0026#39;vertex\u0026#39;, \u0026#39;edge\u0026#39;).by(dedup(local)).by(dedup(local)) // 点和边分开存储，便于可视化绘图 协同推荐 按照权重将不是好友的好友的好友推荐给自己 1 2 3 4 5 6 7 gremlin\u0026gt; g.withSack(1.0f).V(1).aggregate(\u0026#34;friends\u0026#34;). sideEffect(both().aggregate(\u0026#34;friends\u0026#34;)). bothE().sack(mult).by(\u0026#34;weight\u0026#34;).otherV(). bothE().sack(mult).by(\u0026#34;weight\u0026#34;).otherV().as(\u0026#34;last_node\u0026#34;).where(without(\u0026#34;friends\u0026#34;)).dedup(). sack().as(\u0026#34;cost\u0026#34;).order().by(select(\u0026#34;cost\u0026#34;), desc).select(\u0026#34;cost\u0026#34;, \u0026#34;last_node\u0026#34;) ==\u0026gt;[cost:1.0,last_node:v[5]] ==\u0026gt;[cost:0.08000000000000002,last_node:v[6]] 找出我关注的和双向关注的朋友 1 2 3 4 g.V(my_id).sideEffect(__.in().id().aggregate(\u0026#39;subscribe\u0026#39;)). // 关注我的 outE().order().by(\u0026#39;createAt\u0026#39;,desc).inV().sideEffect(__.id().aggregate(\u0026#39;i_subscribe\u0026#39;)). //我关注的 choose(__.id().where(within(\u0026#39;subscribe\u0026#39;)),__.id().aggregate(\u0026#39;both_subscribe\u0026#39;)). //双向关注的 cap(\u0026#39;i_subscribe\u0026#39;,\u0026#39;both_subscribe\u0026#39;) //输出 找出我的好友的好友B，按照B和我之间的共同好友数量进行倒排，作为推荐候选 1 2 3 4 5 6 7 8 9 gremlin\u0026gt; g.V(1).both().aggregate(\u0026#34;my_friend\u0026#34;). // 1度好友 both().has(id, neq(1)).as(\u0026#34;ff\u0026#34;). //2度好友，但不能包含自己 flatMap(__.both().where(within(\u0026#34;my_friend\u0026#34;)).count()). // 和自己共同好友数 as(\u0026#34;comm_cnt\u0026#34;).order().by(desc). // 倒排输出2度好友和共同好友数量 select(\u0026#34;ff\u0026#34;, \u0026#34;comm_cnt\u0026#34;) ==\u0026gt;[ff:v[4],comm_cnt:1] ==\u0026gt;[ff:v[6],comm_cnt:1] ==\u0026gt;[ff:v[5],comm_cnt:1] ==\u0026gt;[ff:v[3],comm_cnt:1] 将teamA球队 朋友球队的球员 按照其所在球队排列，推荐给自己 图片和构图参考gremlin-google官方讨论这里\n1 2 3 4 5 6 7 8 9 10 11 12 gremlin\u0026gt; g.V().has(\u0026#34;name\u0026#34;, \u0026#34;team A\u0026#34;). sideEffect(__.out(\u0026#34;owned\u0026#34;).hasLabel(\u0026#34;player\u0026#34;).aggregate(\u0026#34;my_player\u0026#34;).limit(1)). // 本球队的球员 both(\u0026#34;is_friends_with\u0026#34;).hasLabel(\u0026#34;team\u0026#34;).as(\u0026#34;team2\u0026#34;).out(\u0026#34;owned\u0026#34;).hasLabel(\u0026#34;player\u0026#34;). as(\u0026#34;friends_player\u0026#34;).where(without(\u0026#34;my_player\u0026#34;)).as(\u0026#34;friends_player2\u0026#34;). //朋友球队球员 select(\u0026#34;team2\u0026#34;, \u0026#34;friends_player2\u0026#34;). group().by(select(\u0026#34;friends_player2\u0026#34;)).by(select(\u0026#34;team2\u0026#34;).fold()). //按球员分组 unfold().project(\u0026#34;Player\u0026#34;, \u0026#34;Teams\u0026#34;).by(select(keys).values(\u0026#34;name\u0026#34;)). by(select(values).unfold().values(\u0026#34;name\u0026#34;).fold()) // 投影 ==\u0026gt;[Player:Baggio,Teams:[Eagles]] ==\u0026gt;[Player:Kroll,Teams:[Valladolid]] ==\u0026gt;[Player:Icardi,Teams:[Valladolid]] ==\u0026gt;[Player:Papin,Teams:[Valladolid,Eagles] 特殊需求类 路径按照点、边聚合 Gremlin输出正常的路径是将Vertex、Edge放在一个列表里，比如：\n1 2 3 gremlin\u0026gt; g.V(1).repeat(outE().otherV()).times(2).path() ==\u0026gt;[v[1],e[8][1-knows-\u0026gt;4],v[4],e[10][4-created-\u0026gt;5],v[5]] ==\u0026gt;[v[1],e[8][1-knows-\u0026gt;4],v[4],e[11][4-created-\u0026gt;3],v[3]] 如果用户想把Vertex、Edge 分开输出再两个列表里, 该怎么办呢？\n由于Gremlin语法本身对Element缺少点、边判断的function进行描述，因此本质上是没法做的，但是如果用户知道点的label只有\u0026quot;software\u0026quot;,\u0026ldquo;person\u0026quot;这两类，则可以根据label来进行区分，可以这样写：\n1 2 3 4 5 gremlin\u0026gt; g.V(1).repeat(outE().otherV()).times(2).path(). flatMap(unfold(). group().by(choose(hasLabel(\u0026#34;software\u0026#34;, \u0026#34;person\u0026#34;), __.constant(\u0026#34;vertex\u0026#34;), __.constant(\u0026#34;edge\u0026#34;)))) ==\u0026gt;[edge:[e[8][1-knows-\u0026gt;4],e[10][4-created-\u0026gt;5]],vertex:[v[1],v[4],v[5]]] ==\u0026gt;[edge:[e[8][1-knows-\u0026gt;4],e[11][4-created-\u0026gt;3]],vertex:[v[1],v[4],v[3]]] 所有路径按照点、边聚合 有时候用户期望把所有的路径中的点和边进行聚合，此时可以这样：\n1 2 3 4 5 6 # g.V(1).repeat(outE().otherV()).times(2).path().unfold().group().by(choose(hasLabel(\u0026#34;software\u0026#34;, \u0026#34;person\u0026#34;), __.constant(\u0026#34;vertex\u0026#34;), __.constant(\u0026#34;edge\u0026#34;))).unfold().project(\u0026#34;k\u0026#34;, \u0026#34;v\u0026#34;).by(select(keys)).by(select(values).dedup(local)) g.V(1).repeat(outE().otherV()).times(2).path().unfold(). group().by(choose(hasLabel(\u0026#34;software\u0026#34;, \u0026#34;person\u0026#34;), __.constant(\u0026#34;vertex\u0026#34;), __.constant(\u0026#34;edge\u0026#34;))).unfold(). project(\u0026#34;k\u0026#34;, \u0026#34;v\u0026#34;).by(select(keys)).by(select(values).dedup(local)) ==\u0026gt;[k:edge,v:[e[8][1-knows-\u0026gt;4],e[10][4-created-\u0026gt;5],e[11][4-created-\u0026gt;3]]] ==\u0026gt;[k:vertex,v:[v[1],v[4],v[5],v[3]]] 所有路径按点、边聚合后，返回所有的属性信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 gremlin\u0026gt; g.V(\u0026#39;1\u0026#39;).repeat(bothE(\u0026#39;knows\u0026#39;, \u0026#34;created\u0026#34;).otherV().hasLabel(\u0026#39;person\u0026#39;, \u0026#34;software\u0026#34;).simplePath()).until(__.hasId(\u0026#39;3\u0026#39;).or().loops().is(P.gte(5))).hasId(\u0026#39;3\u0026#39;).path().unfold().dedup().choose(__.hasLabel(\u0026#34;person\u0026#34;, \u0026#34;software\u0026#34;), __.valueMap(true).aggregate(\u0026#34;vertex\u0026#34;), __.project(\u0026#39;inV\u0026#39;, \u0026#39;outV\u0026#39;,\u0026#39;inVlabel\u0026#39;,\u0026#39;outVlabel\u0026#39;, \u0026#34;properteis\u0026#34;).by(inV().id()).by(outV().id()).by(inV().label()).by(outV().label()).by(valueMap(true)).aggregate(\u0026#34;edge\u0026#34;)).tail(1).select(\u0026#34;vertex\u0026#34;, \u0026#34;edge\u0026#34;) g.V(\u0026#39;1\u0026#39;).repeat(bothE(\u0026#39;knows\u0026#39;, \u0026#34;created\u0026#34;).otherV().hasLabel(\u0026#39;person\u0026#39;, \u0026#34;software\u0026#34;).simplePath()). until(__.hasId(\u0026#39;3\u0026#39;).or().loops().is(P.gte(5))).hasId(\u0026#39;3\u0026#39;).path(). // path unfold().dedup(). //去重 choose(__.hasLabel(\u0026#34;person\u0026#34;, \u0026#34;software\u0026#34;), __.valueMap(true).aggregate(\u0026#34;vertex\u0026#34;), // 点去重，返回所有属性 __.project(\u0026#39;inV\u0026#39;, \u0026#39;outV\u0026#39;,\u0026#39;inVlabel\u0026#39;,\u0026#39;outVlabel\u0026#39;, \u0026#34;properteis\u0026#34;). by(inV().id()).by(outV().id()).by(inV().label()).by(outV().label()). by(valueMap(true)).aggregate(\u0026#34;edge\u0026#34;)). //边去重，返回所有属性并且包含in，outv信息 tail(1). select(\u0026#34;vertex\u0026#34;, \u0026#34;edge\u0026#34;) 聚合输出 ==\u0026gt;[vertex:[ [id:1,label:person,name:[marko],age:[29]], [id:3,label:software,name:[lop],lang:[java]], [id:4,label:person,name:[josh],age:[32]] ], edge:[ [inV:3,outV:1,inVlabel:software,outVlabel:person,properteis:[id:9,label:created,weight:0.4]], [inV:4,outV:1,inVlabel:person,outVlabel:person,properteis:[id:8,label:knows,weight:1.0]], [inV:3,outV:4,inVlabel:software,outVlabel:person,properteis:[id:11,label:created,weight:0.4]]]] 类型转换 Gremlin对算子执行算数运算的约束比较死板，如果两个值类型不一致，直接报错。也没有像cypher提供类型转换的函数，但是由于兼容groovy语法，可以利用groovy来进行转换（GDB禁止掉了该语法），比如。\n1 2 gremlin\u0026gt; g.withSack(2).V(1).sack(mult).by(values(\u0026#34;x\u0026#34;).map{(\u0026#39;\u0026#39;+it).toInteger()}).sack() 429 ==\u0026gt;4 批量更新 批量属性插入 属性插入有两种写入，常规的比如：\n1 2 gremlin\u0026gt; g.V(1).property(\u0026#34;k1\u0026#34;, \u0026#34;v1\u0026#34;).property(\u0026#34;k2\u0026#34;, \u0026#39;v2\u0026#39;) ==\u0026gt;v[1] 上面的写法需要把kx，vx分别用property包装起来，除非用脚本生成，一般而言可扩展性比较差，其实可以把properties作为参数，并通过step进行循环插入，比如。\n1 2 3 4 5 6 gremlin\u0026gt; g.inject([[\u0026#39;code\u0026#39;:\u0026#39;L10\u0026#39;, \u0026#39;description\u0026#39;:\u0026#39;Some other area\u0026#39;]]).unfold().as(\u0026#39;properties\u0026#39;). V(1).as(\u0026#39;vertex\u0026#39;). sideEffect(__.select(\u0026#39;properties\u0026#39;).unfold().as(\u0026#39;kv\u0026#39;). select(\u0026#39;vertex\u0026#39;).property(__.select(\u0026#39;kv\u0026#39;).by(Column.keys),__.select(\u0026#39;kv\u0026#39;).by(Column.values))). valueMap() ==\u0026gt;[code:[L10],k1:[v1],k2:[v2],name:[marko],description:[Some other area],age:[29]] 批量插入点、插入边 1 2 3 4 g.addV(\u0026#34;vertex\u0026#34;).property(id,124).as(\u0026#34;start\u0026#34;). addV(\u0026#34;vertex\u0026#34;).property(id,125).as(\u0026#34;end\u0026#34;). sideEffect(addE(\u0026#34;end\u0026#34;).from(select(\u0026#34;start\u0026#34;)).to(select(\u0026#34;end\u0026#34;))). sideEffect(addE(\u0026#34;end2\u0026#34;).from(select(\u0026#34;start\u0026#34;)).to(select(\u0026#34;end\u0026#34;))) 存在就更新，不存在插入 1 2 3 4 5 6 7 8 ## 点 g.inject(\u0026#39;a\u0026#39;).choose(__.V(11),__.V(11).property(\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;),__.addV(\u0026#34;11\u0026#34;).property(id,11).property(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;)) ## 边 g.inject(\u0026#34;Any\u0026#34;).coalesce(g.E(EID), addE(\u0026#34;follow\u0026#34;).from(V(VID1)).to(V(VID2)).property(id, EID)). property(\u0026#34;P1\u0026#34;, V1). property(\u0026#34;P2\u0026#34;, V2). property(\u0026#34;P3\u0026#34;, V3)) 以上复杂场景实战内容转载于用Gremlin探索万物-实用小技巧\n","date":"2022-12-20T16:47:40+08:00","image":"https://blog.staparx.cn/p/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93gdb-gremlin-%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/img_huc2ebc3a27d57369e9bfac8deb1e28c15_91565_120x120_fill_box_smart1_3.png","permalink":"https://blog.staparx.cn/p/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93gdb-gremlin-%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"图数据库GDB - Gremlin 的使用记录"},{"content":"一、基于Hugo搭建个人博客 为何选择Hugo 说白了，就是懒。\n作为一个后端开发，即想要一个稍微好看的博客网站，又不想在前端上下太大的功夫。\n而Hugo静态网站生成，充分满足了我们的需求。\n它不仅解决了Web端环境依赖的问题，并且使用简单、部署方便，支持 Markdown 的写作方式，通过 LiveReload 实时刷新，简直不要太舒服！\n安装Hugo 有go环境 Hugo安装官方文档\n根据文档，直接install下来就完事了。\n1 go install github.com/gohugoio/hugo@latest 相信你的环境变量应该指向了你的 $GOPATH/bin了，直接去检验安装吧。\n没有go环境 Hugo - Releases\n根据自己的操作系统，去下载吧。最后别忘了设置环境变量哦～。\n检验安装 在命令行输入\n1 hugo env -v 显示了hugo版本信息就算成功。\n开始Hugo 创建一个新的博客项目 1 hugo new site blog 添加一个主题 可以自己选择一个喜欢的Hugo - 主题，本站点使用的是hugo-theme-stack。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //进入项目空间 cd blog //初始化git仓库 git init //将主题添加到主模块中 git submodule add git://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack //修改配置文件的主题设置 echo \u0026#39;theme = \u0026#34;hugo-theme-stack\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml // 以下针对 **hugo-theme-stack**这个主题进行配置，若使用的其他主题，可忽略后面的命令。 // 把themes/hugo-theme-stack/exampleSite 文件夹中的config.yaml 复制到站点目录下 cp themes/hugo-theme-stack/exampleSite/config.yaml ./config.yaml //Hugo配置文件会读取config.toml或config.yaml，所以需要把初始化时生成的config.toml删除掉。 rm -rf config.toml // 可以把博客模版\\themes\\hugo-theme-stack\\archetypes 复制到 \\archetypes中 cp themes/hugo-theme-stack/archetypes ./archetypes 使用主题自带的页面 想要初始化的时候有点页面，可以直接将主题文件内的 themes/hugo-theme-stack/exampleSite/content 里面的page和post页面，cp到主站点的content里面。\nPS：重启hugo server后，可能会出现超时的问题，是因为部分页面引用了外网链接，将content/post里面的这两个文件删除就可以正常跑起来了。\nplaceholder-text\nrich-content\n创建新的博客页面 新博客页面统一放置在content/post路径下，使用new命令会根据archetypes内预先配置好的模版创建.md文件。\n1 hugo new posts/new/index.md 本地启动服务 1 hugo server -D 默认端口为 :1313\n直接打开http://localhost:1313/，就可以看到通过主题初始化后的博客啦。\n构建静态页面 1 hugo -D 命令执行后，会在站点目录下生成一个 ./public 文件，所有静态文件都打包在该目录下。\n后续部署会根据该文件进行静态文件部署～\n","date":"2022-12-09T00:00:00Z","image":"https://blog.staparx.cn/p/%E5%9F%BA%E4%BA%8Ehugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2stack%E4%B8%BB%E9%A2%98--githubpages%E6%8C%81%E7%BB%AD%E5%8C%96%E9%83%A8%E7%BD%B2/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.staparx.cn/p/%E5%9F%BA%E4%BA%8Ehugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2stack%E4%B8%BB%E9%A2%98--githubpages%E6%8C%81%E7%BB%AD%E5%8C%96%E9%83%A8%E7%BD%B2/","title":"基于Hugo搭建个人博客（Stack主题 + GithubPages持续化部署）"}]